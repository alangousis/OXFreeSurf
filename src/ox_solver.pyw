"""
By Athanasios V. Serafeim, Anastasios Perdios, Dimitrios Gkikas, Nikolaos Th. Fourniotis and Andreas Langousis.

Apache License

Version 2.0, January 2004
http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. "License" shall mean the terms and
conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. "Licensor"
shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. "Legal
Entity" shall mean the union of the acting entity and all other entities that control, are controlled by,
or are under common control with that entity. For the purposes of this definition, "control" means (i) the power,
direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise,
or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such
entity. "You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License.
"Source" form shall mean the preferred form for making modifications, including but not limited to software source
code, documentation source, and configuration files. "Object" form shall mean any form resulting from mechanical
transformation or translation of a Source form, including but not limited to compiled object code, generated
documentation, and conversions to other media types. "Work" shall mean the work of authorship, whether in Source or
Object form, made available under the License, as indicated by a copyright notice that is included in or attached to
the work (an example is provided in the Appendix below). "Derivative Works" shall mean any work, whether in Source or
Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations,
elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this
License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the
interfaces of, the Work and Derivative Works thereof. "Contribution" shall mean any work of authorship, including the
original version of the Work and any modifications or additions to that Work or Derivative Works thereof,
that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or
Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, "submitted"
means any form of electronic, verbal, or written communication sent to the Licensor or its representatives,
including but not limited to communication on electronic mailing lists, source code control systems,
and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and
improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by
the copyright owner as "Not a Contribution." "Contributor" shall mean Licensor and any individual or Legal Entity on
behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to
You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare
Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works
in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to
You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section)
patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such
license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their
Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was
submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a
lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory
patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of
the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with
or without modifications, and in Source or Object form, provided that You meet the following conditions:

    You must give any other recipients of the Work or Derivative Works a copy of this License; and You must cause any
    modified files to carry prominent notices stating that You changed the files; and You must retain, in the Source
    form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from
    the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and
    If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative Works that You
    distribute must include a readable copy of the attribution notices contained within such NOTICE file,
    excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following
    places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or
    documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative
    Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for
    informational purposes only and do not modify the License. You may add Your own attribution notices within
    Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that
    such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright
    statement to Your modifications and may provide additional or different license terms and conditions for use,
    reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your
    use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for
inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any
additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any
separate license agreement you may have executed with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product
names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and
reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and
each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT,
MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness
of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this
License.

8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract,
or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in
writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental,
or consequential damages of any character arising as a result of this License or out of the use or inability to use
the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction,
or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of
such damages.

9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof,
You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability
obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on
Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to
indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against,
such Contributor by reason of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS

E-mail: athanseraf@hotmail.com, andlag@upatras.gr
"""
# ---------------------Imports----------------------
from scipy import optimize
import numpy as np


# ---------------------Inputs----------------------
def main(Q, b, z, n0, ystart, yend, xp0, yp0, dx):
    """
       This is the main function of the ox_solver as well as the main engine (solver) of the OX_FreeSurf, which
       interacts with the ox_gui.py. It includes the source code for the calculation of the free surface profile along
       the channel, based on the user defined altimetry of reaches and their specific hydraulic characteristics
       (geometry of hydraulic cross section, flow value, starting and terminal depths etc.).

       Parameters
       ----------
       Q: (float) Discharge, in m3/s.
       b: (float) Bottom width, in m.
       z: (float) The wall width to height ratio of the bank's slope.
       n0: (float) Gauckler–Manning coefficient, in s/[m1/3].
       ystart: (float) Starting depth, in m.
       yend: (float) Terminal depth, in m.
       xp0: (list) Nodes X coordinate, in m.
       yp0:(list) Nodes Y coordinate, in m.
       dx: (float) Discretization length, in m.

       Returns
       -------
       xp: (list) X coordinate through the channel, in m.
       yp: (list) Y coordinate through the channel, in m.
       profile: (list) Depth through the channel, in m.
    """
    # ---------------------Checking input data----------------------

    if (
            Q <= 0 or
            b <= 0 or
            n0 <= 0 or
            z < 0 or
            ystart <= 0
    ):
        print('Wrong input data')
        raise ValueError('Check input data.')

    # ---------------------Checking if flow is possible----------------------

    yc = float(ycritical(Q, b, z))
    Emin = minimum_specific_energy(Q, b, z)
    Mmin = minimum_specific_force(Q, b, z)
    E0 = specific_energy(Q, b, ystart, z)
    M0 = specific_force(Q, b, ystart, z)

    if (
            E0 < Emin or
            M0 < Mmin
    ):
        print('Flow is not possible in terms of minimum specific energy and/or force')
        raise ValueError('Check input data.')

    # ---------------------Discretization of the channel----------------------

    xp = list(frange(xp0[0], xp0[len(xp0) - 1] + dx, dx))
    ar_yp = np.interp(xp, xp0, yp0)
    yp = ar_yp.tolist()

    # ---------------------Calculating table of flow characteritics for each part of the channel----------------------

    tab_char = [[0, 0, 0, 0] for _ in range(len(xp) - 1)]

    for i in range(len(xp) - 1):

        tab_char[i][0] = (yp[i] - yp[i + 1]) / (xp[i + 1] - xp[i])
        tab_char[i][1] = ycritical(Q, b, z)

        if (
                tab_char[i][0] == 0  # Case of H curve
        ):
            tab_char[i][2] = float('inf')
            tab_char[i][3] = 4
        elif (
                tab_char[i][0] < 0  # Case of A curve
        ):
            tab_char[i][2] = float('nan')
            tab_char[i][3] = 5
        else:
            tab_char[i][2] = ynormal_Manning(Q, b, n0, tab_char[i][0], z)  # normal depth
            if (
                    tab_char[i][2] > tab_char[i][1]  # Case of M curve
            ):
                tab_char[i][3] = 1
            elif (
                    tab_char[i][2] < tab_char[i][1]  # Case of S curve
            ):
                tab_char[i][3] = 2
            else:  # Case of C curve
                tab_char[i][3] = 3

    # --Identifying control sections (0: regular section, control depth: control section, -1: to be specified at the
    # end of the simulation)--

    ctrl = [[0] for _ in range(len(xp))]

    if (
            tab_char[0][3] == 2 or  # Case of critical or supercritical slope at the first part of the channel
            tab_char[0][3] == 3
    ):
        if (
                ystart > yc
        ):
            ctrl[0] = yc
        else:
            ctrl[0] = ystart
    else:
        ctrl[0] = 0

    for i in range(1, len(xp) - 1):  # Checking which intermediate sections are control sections
        if (
                (tab_char[i - 1][3] != 2 and tab_char[i][3] == 2) or
                (tab_char[i - 1][3] != 2 and tab_char[i][3] == 3)
        ):
            ctrl[i] = yc
        else:
            ctrl[i] = 0

    ctrl[len(xp) - 1] = -1

    # --------downstream free surface integration-------

    locctr = []

    for i in range(len(ctrl)):
        if (
                ctrl[i] > 0
        ):
            locctr += [i]

    dnstr = [0 for _ in range(len(xp))]
    flag_elim_ctrl = []
    m = 0

    if (
            len(locctr) == 1  # Case of only 1 control section
    ):
        if (
                locctr[0] != len(ctrl)  # Case of not at the end of the chanel
        ):
            dnstr[locctr[0]] = ctrl[locctr[0]]
            for j in range(locctr[0] + 1, len(ctrl)):
                tempy = slowly_varying_inter(Q, b, n0, Emin, Mmin, xp[j - 1], dnstr[j - 1], yp[j - 1], xp[j], yp[j], z)
                dnstr[j] = min(tempy, yc)
    else:  # Case of more than 1 control sections
        for i in range(len(locctr) - 1):
            if (
                    ctrl[locctr[i]] > dnstr[locctr[i]] and
                    dnstr[locctr[i]] > 0
            ):
                m += 1
                flag_elim_ctrl += locctr[i]
            else:
                dnstr[locctr[i]] = ctrl[locctr[i]]

            for j in range(locctr[0] + 1, len(ctrl)):
                tempy = slowly_varying_inter(Q, b, n0, Emin, Mmin, xp[j - 1], dnstr[j - 1], yp[j - 1], xp[j], yp[j], z)
                dnstr[j] = min(tempy, yc)

            if (
                    locctr[len(locctr) - 1] != len(ctrl)
            ):
                if (
                        ctrl[locctr[len(locctr) - 1]] > dnstr[locctr[len(locctr) - 1]] and
                        dnstr[locctr[len(locctr) - 1]] > 0
                ):
                    m += 1
                    flag_elim_ctrl += [locctr[len(locctr) - 1]]
                else:
                    dnstr[locctr[len(locctr) - 1]] = ctrl[locctr[len(locctr) - 1]]

                for k in range(locctr[len(locctr) - 1] + 1, len(ctrl)):
                    tempy = slowly_varying_inter(Q, b, n0, Emin, Mmin, xp[k - 1], dnstr[k - 1], yp[k - 1], xp[k], yp[k],
                                                 z)
                    dnstr[k] = min(tempy, yc)
        else:  # Case when end section becomes control section due to subcritical flow along the whole channel
            ctrl[len(ctrl) - 1] = max(yend, yc)
            if (
                    len(locctr) == 0
            ):
                locctr += [len(ctrl)]
            else:
                locctr[0] = len(ctrl)

    # --------Re-defining control sections-------

    if (
            len(flag_elim_ctrl) != 0
    ):
        for i in range(len(flag_elim_ctrl)):
            ctrl[flag_elim_ctrl[i - 1]] = 0
    if (
            ctrl[len(ctrl) - 1] > 0
    ):
        dnstr[len(dnstr) - 1] = ctrl[len(ctrl) - 1]
    else:
        if (
                dnstr[len(dnstr) - 1] < yc
        ):
            if (
                    yend <= conjugate_depth(Q, b, dnstr[len(dnstr) - 1], yc, z)
            ):
                if (
                        yend >= dnstr[len(dnstr) - 1]
                ):
                    dnstr[len(dnstr) - 1] = yend
                    ctrl[len(ctrl) - 1] = 0
            else:
                ctrl[len(ctrl) - 1] = yend
        else:
            if (
                    yend >= yc
            ):
                ctrl[len(ctrl) - 1] = yend
            else:
                ctrl[len(ctrl) - 1] = yc

    # --------upstream free surface integration-------

    locctr = []

    for i in range(len(ctrl)):  # Location control sections
        if (
                ctrl[i] > 0
        ):
            locctr += [i]

    upstr = [0 for _ in range(len(xp))]

    if (
            len(locctr) == 1  # Case of only 1 control section
    ):
        if (
                locctr[len(locctr) - 1] != 0  # Case of not at the beginning of the channel
        ):
            upstr[locctr[len(locctr) - 1]] = ctrl[locctr[len(locctr) - 1]]
            for i in range(locctr[len(locctr) - 1] - 1, -1, -1):
                tempy = slowly_varying_inter(Q, b, n0, Emin, Mmin, xp[i + 1], upstr[i + 1], yp[i + 1], xp[i], yp[i], z)
                upstr[i] = max(tempy, yc)
    else:  # Case of more than 1 control sections
        for i in range(len(locctr) - 1, 0, -1):
            upstr[locctr[i]] = ctrl[locctr[i]]
            for j in range(locctr[i] - 1, locctr[i - 1] - 1, -1):
                tempy = slowly_varying_inter(Q, b, n0, Emin, Mmin, xp[j + 1], upstr[j + 1], yp[j + 1], xp[j], yp[j], z)
                upstr[j] = max(tempy, yc)

        if (
                locctr[0] != 0  # Last control section: Case of not at the beginning of the channel
        ):
            upstr[locctr[0]] = ctrl[locctr[0]]
            for i in range(locctr[len(locctr) - 1] - 1, -1, -1):
                tempy = slowly_varying_inter(Q, b, n0, Emin, Mmin, xp[i + 1], upstr[i + 1], yp[i + 1], xp[i], yp[i], z)
                upstr[i] = max(tempy, yc)

    # --------Scanning all channel for possible hydraulic jumps-------

    profile = []
    flag_flow = []

    if (
            ctrl[0] == 0
    ):
        profile += [upstr[0]]
        flag_flow += [0]  # case of subcritical depth
    else:
        profile += [ctrl[0]]
        flag_flow += [1]  # case of critical or supercritical depth

    for i in range(1, len(xp)):
        if (
                ctrl[i] > 0  # case of more than 1 control sections
        ):
            profile += [ctrl[i]]
            flag_flow += [1]
        else:
            if (
                    dnstr[i] == 0 or
                    (dnstr[i] == yc and tab_char[i][3] != 3)
                    # case of no downstream integration (also identifying dummy critical depths)
            ):
                profile += [upstr[i]]
                flag_flow += [0]
            elif (
                    upstr[i] == 0 or
                    (upstr[i] == yc and tab_char[i][3] != 3)
                    # case of no upstream integration (also identifying dummy critical depths)
            ):
                profile += [dnstr[i]]
                flag_flow += [1]
            else:  # case when both integrations are available (hydraulic jump)
                if (
                        flag_flow[i - 1] == 1  # case of conditioning on supercritical
                ):
                    if (
                            upstr[i] < conjugate_depth(Q, b, dnstr[i], yc, z)
                    ):
                        profile += [dnstr[i]]
                        flag_flow += [1]  # stay with supercritical depth
                    else:
                        profile += [upstr[i]]
                        flag_flow += [0]  # change to subcritical depth
                else:  # case of conditioning on subcritical
                    profile += [upstr[i]]
                    flag_flow += [0]  # stay with subcritical

    # --------Plots-Figures-------
    return xp, yp, profile

    # -------functions------------


def ycritical(Q, b, z=0):
    """
       This function calculates the critical depth in a prismatic channel, assisted by the func function.

       Parameters
       ----------
       Q: (float) Discharge, in m3/s.
       b: (float) Bottom width, in m.
       z: (float) The wall width to height ratio of the bank's slope (default value z=0 corresponds to rectangular
                  channel).
       Returns
       -------
       yc.x: (float) Critical depth, in m.
    """
    toll = 0.0001  # termination tolerance on yc
    init = ((Q ** 2) / (9.81 * (b ** 2))) ** (1 / 3)  # initial value
    yc = optimize.root(func, [init], args=(Q, b, z), method='lm', tol=toll)
    return float(yc.x)


def func(y, *args):
    """
       This function assists the ycritical function by numerical estimating the critical depth, using a prototype step
       method.

       Parameters
       ----------
       y: (float) The initial estimation for the numerical solving, in m.
       Q: (float) Discharge, in m3/s.
       b: (float) Bottom width, in m.
       z: (float) The wall width to height ratio of the bank's slope .

       Returns
       -------
       x: (float) Critical depth, in m.
    """
    A = (args[1] + args[2] * y) * y
    B = args[1] + 2 * args[2] * y
    x = ((args[0] ** 2) * B) / 9.81 / (A ** 3) - 1.0
    return x


def minimum_specific_energy(Q, b, z=0):
    """
       This function calculates the minimum possible value of specific energy required for a flow with the user defined
       characteristics to be possible, in a prismatic channel.

       Parameters
       ----------
       Q: (float) Discharge, in m3/s.
       b: (float) Bottom width, in m.
       z: (float) The wall width to height ratio of the bank's slope (default value z=0 corresponds to rectangular
                  channel).
       Returns
       -------
       Emin: (float) Minimum specific energy, in m.
    """
    yc = ycritical(Q, b, z)
    Bc = b + 2 * z * yc
    Ac = (b + Bc) * yc / 2
    Emin = yc + ((Q / Ac) ** 2) / 2 / 9.81
    return Emin


def minimum_specific_force(Q, b, z=0):
    """
       This function calculates the minimum possible values of specific force required for a flow with the user defined
       characteristics to be possible, in a prismatic channel.

       Parameters
       ----------
       Q: (float) Discharge, in m3/s.
       b: (float) Bottom width, in m.
       z: (float) The wall width to height ratio of the bank's slope (default value z=0 corresponds to rectangular
                  channel).
       Returns
       -------
       Mmin: (float) Minimum specific force, in m^3.
    """
    yc = ycritical(Q, b, z)
    Mmin = (Q ** 2) / 9.81 / (b * yc + z * yc ** 2) + (2 * z * (yc ** 3) + 3 * b * (yc ** 2)) / 6
    return Mmin


def specific_energy(Q, b, y1, z=0):
    """
       This function calculates the specific energy of the flow, in a prismatic channel.

       Parameters
       ----------
       Q: (float) Discharge, in m3/s.
       b: (float) Bottom width, in m.
       y1: (float) Flow depth, in m.
       z: (float) The wall width to height ratio of the bank's slope (default value z=0 corresponds to rectangular
                  channel).
       Returns
       -------
       E: (float) Specific energy, in m.
    """
    if (
            y1 < 0
    ):
        print('Inconsistent input data, y1<0 in specific_energy!')
        raise ValueError('Check input data.')
    elif (
            Q == 0 and
            y1 >= 0
    ):
        E = y1
        return E
    elif (
            Q > 0 and
            y1 == 0
    ):
        print('Inconsistent input data (Q>0 and y1==0)')
        raise ValueError('Check input data.')
    else:
        B1 = b + 2 * z * y1
        A1 = (b + B1) * y1 / 2
        E = y1 + ((Q / A1) ** 2) / 2 / 9.81
        return E


def specific_force(Q, b, y1, z=0):
    """
       This function calculates the specific force of the flow, in a prismatic channel.

       Parameters
       ----------
       Q: (float) Discharge, in m3/s.
       b: (float) Bottom width, in m.
       y1: (float) Flow depth, in m.
       z: (float) The wall width to height ratio of the bank's slope (default value z=0 corresponds to rectangular
                  channel).
       Returns
       -------
       Mmin: (float) Specific force, in m^3.
    """
    if (
            y1 < 0
    ):
        print('Inconsistent input data, y1 < 0')
        raise ValueError('Check input data.')
    elif (
            Q == 0 and
            y1 >= 0
    ):
        M = (Q ** 2) / 9.81 / (b * y1 + z * y1 ** 2) + (2 * z * (y1 ** 3) + 3 * b * (y1 ** 2)) / 6
        return M
    elif (
            Q > 0 and
            y1 == 0
    ):
        print('Inconsistent input data (Q>0 and y1==0), check!')
        raise ValueError('Check input data.')
    else:
        M = (Q ** 2) / 9.81 / (b * y1 + z * y1 ** 2) + (
                2 * z * (y1 ** 3) + 3 * b * (y1 ** 2)) / 6
        return M


def frange(start, stop, step=1):
    """
       This function assists the channel's discretization, by returning the current step number for each x estimation.

       Parameters
       ----------
       start: (float) The initial point of the current hydraulic section, in m.
       stop: (float) The terminal point of the current hydraulic section, in m.
       step: (float) Discretization length (default value step=1 corresponds to 1 m discretization length).

       Returns
       -------
       i: (int) Number of step.
    """
    i = start
    while i < stop:
        yield i
        i += step


def ynormal_Manning(Q, b, n0, s0, z=0):
    """
       This function calculates the normal depth for a given Gauckler–Manning coefficient for prismatic channels,
       assisted by the funnorm function.

       Parameters
       ----------
       Q: (float) Discharge, in m3/s.
       b: (float) Bottom width, in m.
       n0: (float) Gauckler–Manning coefficient, in s/[m1/3].
       s0: (float) Bottom slope (m/m).
       z: (float) The wall width to height ratio of the bank's slope (default value z=0 corresponds to rectangular
                  channel).

       Returns
       -------
       yn.x: (float) Normal depth, in m.
    """
    if (
            n0 <= 0 or
            s0 <= 0
    ):
        print('Inconsistent input data, s0 <= 0')
        raise ValueError('Check input data.')
    else:
        toll = 0.0001
        init = 1.0
        yn = optimize.root(funnorm, [init], args=(Q, b, n0, s0, z), method='lm', tol=toll)
        return float(yn.x)


def funnorm(y, *args):
    """
       This function assists the ynormal_Manning function by numerical estimating the normal depth, using a prototype
       step method.

       Parameters
       ----------
       y: (float) The initial estimation for the numerical solving, in m.
       Q: (float) Discharge, in m3/s.
       b: (float) Bottom width, in m.
       n0: (float) Gauckler–Manning coefficient, in s/[m1/3].
       S0: (float) Bottom slope (m/m).
       z: (float) The wall width to height ratio of the bank's slope.

       Returns
       -------
       x: (float) Normal depth, in m.
    """
    B = args[1] + 2 * args[4] * y
    A = (args[1] + B) * y / 2
    P = args[1] + 2 * y * (1 + args[4] ** 2) ** 0.5
    x = args[0] - (A ** (5 / 3)) / (P ** (2 / 3)) / args[2] * (args[3] ** 0.5)
    return x


def slowly_varying_inter(Q, b, n0, Emin, Mmin, x1, y1, elev1, x2, elev2, z=0):
    """
       This function calculates calculates the flow depth values for the portions of teh channel where numerical
       integration proceeds downstream of he control section, assisted by the ftest function.

       Parameters
       ----------
       Q: (float) Discharge, in m3/s.
       b: (float) Bottom width, in m.
       n0: (float) Gauckler–Manning coefficient, in s/[m1/3].
       Emin: (float) Minimum specific energy, in m.
       Mmin: (float) Minimum specific force, in m^3.
       x1: (float) Starting location of the integration, in m from some reference point along the horizontal axis.
       y1: (float) Starting depth of the flow, in m.
       elev1: (float) Elevation of the bottom at the starting location of the integration, in m from some reference
                      point along the vertical axis.
       x2: (float) End location of the integration, in m from some reference point along the horizontal axis.
       elev2: (float) Elevation of the bottom at the end location of the integration, in m from some reference point
                      along the vertical axis.
       z: (float) The wall width to height ratio of the bank's slope (default value z=0 corresponds to rectangular
                  channel).

       Returns
       -------
       y2.x: (float) Depth of the flow at the end location of the integration, in m.
    """
    if (
            y1 <= 0
    ):
        print('Inconsistent input data, y1 <= 0')
        raise ValueError('Check input data.')
    else:
        E0 = specific_energy(Q, b, y1, z)
        M0 = specific_force(Q, b, y1, z)
        if (
                E0 < Emin or
                M0 < Mmin
        ):
            print('Flow is not possible in terms of minimum specific energy and/or force')
            raise ValueError('Check input data.')
        else:
            A1 = (b + z * y1) * y1
            V1 = Q / A1
            H1 = elev1 + y1 + (V1 ** 2) / 2 / 9.81
            dx1 = x2 - x1
            toll = 0.0001
            init = y1
            y2 = optimize.root(ftest, [init], args=(Q, b, z, n0, H1, dx1, elev2), method='lm', tol=toll)
            return float(y2.x)


def ftest(y, *args):
    """
       This function assists the slowly_varying_inter function by numerical estimating the depth of the flow using a
       prototype step method.

       Parameters
       ----------
       y: (float) The initial estimation for the numerical solving, in m.
       Q: (float) Discharge, in m3/s.
       b: (float) Bottom width, in m.
       z: (float) The wall width to height ratio of the bank's slope.
       n0: (float) Gauckler–Manning coefficient, in s/[m1/3].
       H1: (float) elev1 + y1 + (V1 ** 2) / 2 / 9.81
       dx1: x2 - x1
       elev2: (float) Elevation of the bottom at the end location of the integration, in m from some reference point
                      along the vertical axis.

       Returns
       -------
       x: (float) Depth of the flow at the end location of the integration, in m.
    """
    A2 = (args[1] + args[2] * y) * y
    V2 = args[0] / A2
    P2 = args[1] + 2 * y * (1 + args[2] ** 2) ** 0.5
    R2 = A2 / P2
    SF = -((args[3] * V2) ** 2) / (R2 ** (4 / 3))
    x = y + args[6] + (V2 ** 2) / 2 / 9.81 - args[4] - SF * args[5]
    return x


def conjugate_depth(Q, b, y1, yc, z=0):
    """
       This function calculates the conjugate depth (same specific force) for a given flow depth in a prismatic
       channel, assisted by the fconj function.

       Parameters
       ----------
       Q: (float) Discharge, in m3/s.
       b: (float) Bottom width, in m.
       y1: (float) Flow depth, in m.
       yc: (float) The critical depth, in m.
       z: (float) The wall width to height ratio of the bank's slope (default value z=0 corresponds to rectangular
                  channel).
       Returns
       -------
       y2.x: (float) Conjugate depth, in m.
    """
    if (
            y1 < 0
    ):
        print('Inconsistent input data, y1 < 0')
        raise ValueError('Check input data.')
    elif (
            Q == 0 and
            y1 >= 0
    ):
        y2 = y1
        return float(y2)
    elif (
            Q > 0 and
            y1 == 0
    ):
        print('conjugate_depth.m: inconsistent input data (Q>0 and y1==0)')
        raise ValueError('Check input data.')
    else:
        M = specific_force(Q, b, y1, z)
        toll = 0.0001
        if (
                y1 == yc
        ):
            y2 = y1
            return float(y2)
        elif (
                y1 > yc
        ):
            init = yc * 0.9
        else:
            init = yc * 1.1

        y2 = optimize.root(fconj, [init], args=(Q, b, z, M), method='lm', tol=toll)
        return float(y2.x)


def fconj(y, *args):
    """
       This function assists the conjugate_depth function by numerical estimating the conjugate depth using the distance
       from free surface to the geometric center of the wet cross-sectional area.

       Parameters
       ----------
       y: (float) The initial estimation for the numerical solving, in m.
       Q: (float) Discharge, in m3/s.
       b: (float) Bottom width, in m.
       z: (float) The wall width to height ratio of the bank's slope.
       M: (float) Specific force, in m^3.

       Returns
       -------
       x: (float) Conjugate depth, in m.
    """
    B2 = args[1] + 2 * args[2] * y
    A2 = (args[1] + B2) * y / 2
    yk = (2 * args[2] * (y ** 3) + 3 * args[1] * (y ** 2)) / 6 / A2
    x = args[3] - (args[0] ** 2 / (9.81 * A2)) - yk * A2
    return x
